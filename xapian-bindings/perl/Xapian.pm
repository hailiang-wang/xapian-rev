# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.13
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Xapian;
use base qw(Exporter);
use base qw(DynaLoader);
package Xapianc;
bootstrap Xapian;
package Xapian;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Xapian;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Xapian;

*newN = *Xapianc::newN;
*version_string = *Xapianc::version_string;
*major_version = *Xapianc::major_version;
*minor_version = *Xapianc::minor_version;
*revision = *Xapianc::revision;
*__or__ = *Xapianc::__or__;
*__xor__ = *Xapianc::__xor__;
*__mul__ = *Xapianc::__mul__;
*__div__ = *Xapianc::__div__;
*__and__ = *Xapianc::__and__;
*__eq__ = *Xapianc::__eq__;
*__lt__ = *Xapianc::__lt__;
*__gt__ = *Xapianc::__gt__;
*__ge__ = *Xapianc::__ge__;
*__le__ = *Xapianc::__le__;
*__add__ = *Xapianc::__add__;
*sortable_serialise = *Xapianc::sortable_serialise;
*sortable_unserialise = *Xapianc::sortable_unserialise;
*miles_to_metres = *Xapianc::miles_to_metres;
*metres_to_miles = *Xapianc::metres_to_miles;
*__ne__ = *Xapianc::__ne__;
*remote_open = *Xapianc::remote_open;
*remote_open_writable = *Xapianc::remote_open_writable;

############# Class : Xapian::Error ##############

package Xapian::Error;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*get_type = *Xapianc::Error_get_type;
*get_msg = *Xapianc::Error_get_msg;
*get_context = *Xapianc::Error_get_context;
*get_error_string = *Xapianc::Error_get_error_string;
*get_description = *Xapianc::Error_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Error($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::LogicError ##############

package Xapian::LogicError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Error Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_LogicError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::RuntimeError ##############

package Xapian::RuntimeError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Error Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_RuntimeError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::AssertionError ##############

package Xapian::AssertionError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::LogicError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_AssertionError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_AssertionError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::InvalidArgumentError ##############

package Xapian::InvalidArgumentError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::LogicError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_InvalidArgumentError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_InvalidArgumentError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::InvalidOperationError ##############

package Xapian::InvalidOperationError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::LogicError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_InvalidOperationError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_InvalidOperationError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::UnimplementedError ##############

package Xapian::UnimplementedError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::LogicError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_UnimplementedError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_UnimplementedError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseError ##############

package Xapian::DatabaseError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseCorruptError ##############

package Xapian::DatabaseCorruptError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::DatabaseError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseCorruptError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseCorruptError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseCreateError ##############

package Xapian::DatabaseCreateError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::DatabaseError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseCreateError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseCreateError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseLockError ##############

package Xapian::DatabaseLockError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::DatabaseError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseLockError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseLockError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseModifiedError ##############

package Xapian::DatabaseModifiedError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::DatabaseError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseModifiedError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseModifiedError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseOpeningError ##############

package Xapian::DatabaseOpeningError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::DatabaseError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseOpeningError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseOpeningError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseVersionError ##############

package Xapian::DatabaseVersionError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::DatabaseOpeningError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseVersionError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseVersionError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DocNotFoundError ##############

package Xapian::DocNotFoundError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DocNotFoundError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DocNotFoundError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::FeatureUnavailableError ##############

package Xapian::FeatureUnavailableError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_FeatureUnavailableError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_FeatureUnavailableError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::InternalError ##############

package Xapian::InternalError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_InternalError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_InternalError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::NetworkError ##############

package Xapian::NetworkError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_NetworkError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_NetworkError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::NetworkTimeoutError ##############

package Xapian::NetworkTimeoutError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::NetworkError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_NetworkTimeoutError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_NetworkTimeoutError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::QueryParserError ##############

package Xapian::QueryParserError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_QueryParserError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_QueryParserError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::SerialisationError ##############

package Xapian::SerialisationError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_SerialisationError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_SerialisationError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::RangeError ##############

package Xapian::RangeError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_RangeError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_RangeError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::WildcardError ##############

package Xapian::WildcardError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RuntimeError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_WildcardError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_WildcardError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseNotFoundError ##############

package Xapian::DatabaseNotFoundError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::DatabaseOpeningError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseNotFoundError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseNotFoundError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DatabaseClosedError ##############

package Xapian::DatabaseClosedError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::DatabaseError Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DatabaseClosedError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DatabaseClosedError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::PositionIterator ##############

package Xapian::PositionIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_PositionIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_PositionIterator($self);
        delete $OWNER{$self};
    }
}

*skip_to = *Xapianc::PositionIterator_skip_to;
*get_description = *Xapianc::PositionIterator_get_description;
*equal1 = *Xapianc::PositionIterator_equal1;
*nequal1 = *Xapianc::PositionIterator_nequal1;
*equals = *Xapianc::PositionIterator_equals;
*get_termpos = *Xapianc::PositionIterator_get_termpos;
*increment = *Xapianc::PositionIterator_increment;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::PostingIterator ##############

package Xapian::PostingIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_PostingIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_PostingIterator($self);
        delete $OWNER{$self};
    }
}

*get_wdf = *Xapianc::PostingIterator_get_wdf;
*get_doclength = *Xapianc::PostingIterator_get_doclength;
*get_unique_terms = *Xapianc::PostingIterator_get_unique_terms;
*positionlist_begin = *Xapianc::PostingIterator_positionlist_begin;
*positionlist_end = *Xapianc::PostingIterator_positionlist_end;
*skip_to = *Xapianc::PostingIterator_skip_to;
*get_description = *Xapianc::PostingIterator_get_description;
*equal = *Xapianc::PostingIterator_equal;
*nequal = *Xapianc::PostingIterator_nequal;
*equals = *Xapianc::PostingIterator_equals;
*get_docid = *Xapianc::PostingIterator_get_docid;
*increment = *Xapianc::PostingIterator_increment;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::TermIterator ##############

package Xapian::TermIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_TermIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_TermIterator($self);
        delete $OWNER{$self};
    }
}

*get_wdf = *Xapianc::TermIterator_get_wdf;
*get_termfreq = *Xapianc::TermIterator_get_termfreq;
*positionlist_count = *Xapianc::TermIterator_positionlist_count;
*positionlist_begin = *Xapianc::TermIterator_positionlist_begin;
*positionlist_end = *Xapianc::TermIterator_positionlist_end;
*skip_to = *Xapianc::TermIterator_skip_to;
*get_description = *Xapianc::TermIterator_get_description;
*equal = *Xapianc::TermIterator_equal;
*nequal = *Xapianc::TermIterator_nequal;
*equals = *Xapianc::TermIterator_equals;
*get_termname = *Xapianc::TermIterator_get_termname;
*increment = *Xapianc::TermIterator_increment;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ValueIterator ##############

package Xapian::ValueIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ValueIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ValueIterator($self);
        delete $OWNER{$self};
    }
}

*get_docid = *Xapianc::ValueIterator_get_docid;
*get_valueno = *Xapianc::ValueIterator_get_valueno;
*skip_to = *Xapianc::ValueIterator_skip_to;
*check = *Xapianc::ValueIterator_check;
*get_description = *Xapianc::ValueIterator_get_description;
*equal = *Xapianc::ValueIterator_equal;
*nequal = *Xapianc::ValueIterator_nequal;
*equals = *Xapianc::ValueIterator_equals;
*get_value = *Xapianc::ValueIterator_get_value;
*increment = *Xapianc::ValueIterator_increment;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Document ##############

package Xapian::Document;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_Document(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Document($self);
        delete $OWNER{$self};
    }
}

*get_value = *Xapianc::Document_get_value;
*add_value = *Xapianc::Document_add_value;
*remove_value = *Xapianc::Document_remove_value;
*clear_values = *Xapianc::Document_clear_values;
*get_data = *Xapianc::Document_get_data;
*set_data = *Xapianc::Document_set_data;
*add_posting = *Xapianc::Document_add_posting;
*add_term = *Xapianc::Document_add_term;
*add_boolean_term = *Xapianc::Document_add_boolean_term;
*remove_posting = *Xapianc::Document_remove_posting;
*remove_postings = *Xapianc::Document_remove_postings;
*remove_term = *Xapianc::Document_remove_term;
*clear_terms = *Xapianc::Document_clear_terms;
*termlist_count = *Xapianc::Document_termlist_count;
*termlist_begin = *Xapianc::Document_termlist_begin;
*termlist_end = *Xapianc::Document_termlist_end;
*values_count = *Xapianc::Document_values_count;
*values_begin = *Xapianc::Document_values_begin;
*values_end = *Xapianc::Document_values_end;
*get_docid = *Xapianc::Document_get_docid;
*serialise = *Xapianc::Document_serialise;
*unserialise = *Xapianc::Document_unserialise;
*get_description = *Xapianc::Document_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Registry ##############

package Xapian::Registry;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_Registry(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Registry($self);
        delete $OWNER{$self};
    }
}

*register_weighting_scheme = *Xapianc::Registry_register_weighting_scheme;
*get_weighting_scheme = *Xapianc::Registry_get_weighting_scheme;
*register_posting_source = *Xapianc::Registry_register_posting_source;
*get_posting_source = *Xapianc::Registry_get_posting_source;
*register_match_spy = *Xapianc::Registry_register_match_spy;
*get_match_spy = *Xapianc::Registry_get_match_spy;
*register_lat_long_metric = *Xapianc::Registry_register_lat_long_metric;
*get_lat_long_metric = *Xapianc::Registry_get_lat_long_metric;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Query ##############

package Xapian::Query;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*OP_AND = *Xapianc::Query_OP_AND;
*OP_OR = *Xapianc::Query_OP_OR;
*OP_AND_NOT = *Xapianc::Query_OP_AND_NOT;
*OP_XOR = *Xapianc::Query_OP_XOR;
*OP_AND_MAYBE = *Xapianc::Query_OP_AND_MAYBE;
*OP_FILTER = *Xapianc::Query_OP_FILTER;
*OP_NEAR = *Xapianc::Query_OP_NEAR;
*OP_PHRASE = *Xapianc::Query_OP_PHRASE;
*OP_VALUE_RANGE = *Xapianc::Query_OP_VALUE_RANGE;
*OP_SCALE_WEIGHT = *Xapianc::Query_OP_SCALE_WEIGHT;
*OP_ELITE_SET = *Xapianc::Query_OP_ELITE_SET;
*OP_VALUE_GE = *Xapianc::Query_OP_VALUE_GE;
*OP_VALUE_LE = *Xapianc::Query_OP_VALUE_LE;
*OP_SYNONYM = *Xapianc::Query_OP_SYNONYM;
*OP_MAX = *Xapianc::Query_OP_MAX;
*OP_WILDCARD = *Xapianc::Query_OP_WILDCARD;
*OP_INVALID = *Xapianc::Query_OP_INVALID;
*WILDCARD_LIMIT_ERROR = *Xapianc::Query_WILDCARD_LIMIT_ERROR;
*WILDCARD_LIMIT_FIRST = *Xapianc::Query_WILDCARD_LIMIT_FIRST;
*WILDCARD_LIMIT_MOST_FREQUENT = *Xapianc::Query_WILDCARD_LIMIT_MOST_FREQUENT;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Query($self);
        delete $OWNER{$self};
    }
}

*get_terms_begin = *Xapianc::Query_get_terms_begin;
*get_terms_end = *Xapianc::Query_get_terms_end;
*get_unique_terms_begin = *Xapianc::Query_get_unique_terms_begin;
*get_length = *Xapianc::Query_get_length;
*empty = *Xapianc::Query_empty;
*serialise = *Xapianc::Query_serialise;
*unserialise = *Xapianc::Query_unserialise;
*get_type = *Xapianc::Query_get_type;
*get_num_subqueries = *Xapianc::Query_get_num_subqueries;
*get_subquery = *Xapianc::Query_get_subquery;
*get_description = *Xapianc::Query_get_description;
sub new {
  my $class = shift;
  my $query;

  if( @_ <= 1 ) {
    $query = Xapianc::new_Query(@_);
  } else {
    use Carp;
    my $op = $_[0];
    if( $op !~ /^\d+$/ ) {
	Carp::croak( "USAGE: $class->new('term') or $class->new(OP, <args>)" );
    }
    if( $op == 8 ) { # FIXME: 8 is OP_VALUE_RANGE; eliminate hardcoded literal
      if( @_ != 4 ) {
	Carp::croak( "USAGE: $class->new(OP_VALUE_RANGE, VALNO, START, END)" );
      }
      $query = Xapianc::new_Query( @_ );
    } elsif( $op == 9 ) { # FIXME: OP_SCALE_WEIGHT
      if( @_ != 3 ) {
	Carp::croak( "USAGE: $class->new(OP_SCALE_WEIGHT, QUERY, FACTOR)" );
      }
      $query = Xapianc::new_Query( @_ );
    } elsif( $op == 11 || $op == 12 ) { # FIXME: OP_VALUE_GE, OP_VALUE_LE; eliminate hardcoded literals
      if( @_ != 3 ) {
	Carp::croak( "USAGE: $class->new(OP_VALUE_[GL]E, VALNO, LIMIT)" );
      }
      $query = Xapianc::new_Query( @_ );
    } else {
      shift @_;
      $query = Xapian::newN( $op, \@_ );
    }
  }
  return $query;
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Stem ##############

package Xapian::Stem;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_Stem(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Stem($self);
        delete $OWNER{$self};
    }
}

*__call__ = *Xapianc::Stem___call__;
*get_description = *Xapianc::Stem_get_description;
*get_available_languages = *Xapianc::Stem_get_available_languages;
*stem_word = *Xapianc::Stem_stem_word;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::TermGenerator ##############

package Xapian::TermGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_TermGenerator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_TermGenerator($self);
        delete $OWNER{$self};
    }
}

*set_stemmer = *Xapianc::TermGenerator_set_stemmer;
*set_stopper = *Xapianc::TermGenerator_set_stopper;
*set_document = *Xapianc::TermGenerator_set_document;
*get_document = *Xapianc::TermGenerator_get_document;
*set_database = *Xapianc::TermGenerator_set_database;
*FLAG_SPELLING = *Xapianc::TermGenerator_FLAG_SPELLING;
*FLAG_CJK_NGRAM = *Xapianc::TermGenerator_FLAG_CJK_NGRAM;
*STEM_NONE = *Xapianc::TermGenerator_STEM_NONE;
*STEM_SOME = *Xapianc::TermGenerator_STEM_SOME;
*STEM_ALL = *Xapianc::TermGenerator_STEM_ALL;
*STEM_ALL_Z = *Xapianc::TermGenerator_STEM_ALL_Z;
*STEM_SOME_FULL_POS = *Xapianc::TermGenerator_STEM_SOME_FULL_POS;
*STOP_NONE = *Xapianc::TermGenerator_STOP_NONE;
*STOP_ALL = *Xapianc::TermGenerator_STOP_ALL;
*STOP_STEMMED = *Xapianc::TermGenerator_STOP_STEMMED;
*set_flags = *Xapianc::TermGenerator_set_flags;
*set_stemming_strategy = *Xapianc::TermGenerator_set_stemming_strategy;
*set_stopper_strategy = *Xapianc::TermGenerator_set_stopper_strategy;
*set_max_word_length = *Xapianc::TermGenerator_set_max_word_length;
*index_text = *Xapianc::TermGenerator_index_text;
*index_text_without_positions = *Xapianc::TermGenerator_index_text_without_positions;
*increase_termpos = *Xapianc::TermGenerator_increase_termpos;
*get_termpos = *Xapianc::TermGenerator_get_termpos;
*set_termpos = *Xapianc::TermGenerator_set_termpos;
*get_description = *Xapianc::TermGenerator_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::MSet ##############

package Xapian::MSet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_MSet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_MSet($self);
        delete $OWNER{$self};
    }
}

*convert_to_percent = *Xapianc::MSet_convert_to_percent;
*get_termfreq = *Xapianc::MSet_get_termfreq;
*get_termweight = *Xapianc::MSet_get_termweight;
*get_firstitem = *Xapianc::MSet_get_firstitem;
*get_matches_lower_bound = *Xapianc::MSet_get_matches_lower_bound;
*get_matches_estimated = *Xapianc::MSet_get_matches_estimated;
*get_matches_upper_bound = *Xapianc::MSet_get_matches_upper_bound;
*get_uncollapsed_matches_lower_bound = *Xapianc::MSet_get_uncollapsed_matches_lower_bound;
*get_uncollapsed_matches_estimated = *Xapianc::MSet_get_uncollapsed_matches_estimated;
*get_uncollapsed_matches_upper_bound = *Xapianc::MSet_get_uncollapsed_matches_upper_bound;
*get_max_attained = *Xapianc::MSet_get_max_attained;
*get_max_possible = *Xapianc::MSet_get_max_possible;
*SNIPPET_BACKGROUND_MODEL = *Xapianc::MSet_SNIPPET_BACKGROUND_MODEL;
*SNIPPET_EXHAUSTIVE = *Xapianc::MSet_SNIPPET_EXHAUSTIVE;
*SNIPPET_EMPTY_WITHOUT_MATCH = *Xapianc::MSet_SNIPPET_EMPTY_WITHOUT_MATCH;
*snippet = *Xapianc::MSet_snippet;
*fetch = *Xapianc::MSet_fetch;
*size = *Xapianc::MSet_size;
*empty = *Xapianc::MSet_empty;
*begin = *Xapianc::MSet_begin;
*end = *Xapianc::MSet_end;
*back = *Xapianc::MSet_back;
*get_description = *Xapianc::MSet_get_description;
*FETCH = *Xapianc::MSet_FETCH;
*get_docid = *Xapianc::MSet_get_docid;
*get_document = *Xapianc::MSet_get_document;
*get_hit = *Xapianc::MSet_get_hit;
*get_document_percentage = *Xapianc::MSet_get_document_percentage;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::MSetIterator ##############

package Xapian::MSetIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*swig_mset_get = *Xapianc::MSetIterator_mset_get;
*swig_mset_set = *Xapianc::MSetIterator_mset_set;
*swig_off_from_end_get = *Xapianc::MSetIterator_off_from_end_get;
*swig_off_from_end_set = *Xapianc::MSetIterator_off_from_end_set;
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_MSetIterator(@_);
    bless $self, $pkg if defined($self);
}

*get_rank = *Xapianc::MSetIterator_get_rank;
*get_document = *Xapianc::MSetIterator_get_document;
*get_weight = *Xapianc::MSetIterator_get_weight;
*get_collapse_key = *Xapianc::MSetIterator_get_collapse_key;
*get_collapse_count = *Xapianc::MSetIterator_get_collapse_count;
*get_sort_key = *Xapianc::MSetIterator_get_sort_key;
*get_percent = *Xapianc::MSetIterator_get_percent;
*get_description = *Xapianc::MSetIterator_get_description;
*equal = *Xapianc::MSetIterator_equal;
*nequal = *Xapianc::MSetIterator_nequal;
*equals = *Xapianc::MSetIterator_equals;
*get_docid = *Xapianc::MSetIterator_get_docid;
*increment = *Xapianc::MSetIterator_increment;
*prev = *Xapianc::MSetIterator_prev;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_MSetIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ESet ##############

package Xapian::ESet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ESet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ESet($self);
        delete $OWNER{$self};
    }
}

*size = *Xapianc::ESet_size;
*empty = *Xapianc::ESet_empty;
*get_ebound = *Xapianc::ESet_get_ebound;
*begin = *Xapianc::ESet_begin;
*end = *Xapianc::ESet_end;
*back = *Xapianc::ESet_back;
*get_description = *Xapianc::ESet_get_description;
*FETCH = *Xapianc::ESet_FETCH;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ESetIterator ##############

package Xapian::ESetIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*swig_eset_get = *Xapianc::ESetIterator_eset_get;
*swig_eset_set = *Xapianc::ESetIterator_eset_set;
*swig_off_from_end_get = *Xapianc::ESetIterator_off_from_end_get;
*swig_off_from_end_set = *Xapianc::ESetIterator_off_from_end_set;
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ESetIterator(@_);
    bless $self, $pkg if defined($self);
}

*get_weight = *Xapianc::ESetIterator_get_weight;
*get_description = *Xapianc::ESetIterator_get_description;
*get_termname = *Xapianc::ESetIterator_get_termname;
*equal = *Xapianc::ESetIterator_equal;
*nequal = *Xapianc::ESetIterator_nequal;
*equals = *Xapianc::ESetIterator_equals;
*get_term = *Xapianc::ESetIterator_get_term;
*increment = *Xapianc::ESetIterator_increment;
*prev = *Xapianc::ESetIterator_prev;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ESetIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::RSet ##############

package Xapian::RSet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_RSet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_RSet($self);
        delete $OWNER{$self};
    }
}

*size = *Xapianc::RSet_size;
*empty = *Xapianc::RSet_empty;
*add_document = *Xapianc::RSet_add_document;
*remove_document = *Xapianc::RSet_remove_document;
*contains = *Xapianc::RSet_contains;
*get_description = *Xapianc::RSet_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::MatchDecider ##############

package Xapian::MatchDecider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *Xapianc::MatchDecider___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_MatchDecider($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Enquire ##############

package Xapian::Enquire;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_Enquire(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Enquire($self);
        delete $OWNER{$self};
    }
}

sub set_query {
  my $self = shift;
  my $query = shift;
  if( ref( $query ) ne 'Xapian::Query' ) {
    $query = Xapian::Query->new( $query, @_ );
    Xapianc::Enquire_set_query( $self, $query );
    return;
  }
  my $nargs = scalar(@_);
  if( $nargs > 1) {
    use Carp;
    Carp::carp( "USAGE: \$enquire->set_query(\$query) or \$enquire->set_query(\$query, \$length)" );
    exit;
  }
  Xapianc::Enquire_set_query( $self, $query, @_ );
}

*get_query = *Xapianc::Enquire_get_query;
*add_matchspy = *Xapianc::Enquire_add_matchspy;
*clear_matchspies = *Xapianc::Enquire_clear_matchspies;
*set_weighting_scheme = *Xapianc::Enquire_set_weighting_scheme;
*set_expansion_scheme = *Xapianc::Enquire_set_expansion_scheme;
*set_collapse_key = *Xapianc::Enquire_set_collapse_key;
*ASCENDING = *Xapianc::Enquire_ASCENDING;
*DESCENDING = *Xapianc::Enquire_DESCENDING;
*DONT_CARE = *Xapianc::Enquire_DONT_CARE;
*set_docid_order = *Xapianc::Enquire_set_docid_order;
*set_cutoff = *Xapianc::Enquire_set_cutoff;
*set_sort_by_relevance = *Xapianc::Enquire_set_sort_by_relevance;
*set_sort_by_value = *Xapianc::Enquire_set_sort_by_value;
sub set_sort_by_key {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    Xapianc::Enquire_set_sort_by_key( @_ );
}

*set_sort_by_value_then_relevance = *Xapianc::Enquire_set_sort_by_value_then_relevance;
sub set_sort_by_key_then_relevance {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    Xapianc::Enquire_set_sort_by_key_then_relevance( @_ );
}

*set_sort_by_relevance_then_value = *Xapianc::Enquire_set_sort_by_relevance_then_value;
sub set_sort_by_relevance_then_key {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    Xapianc::Enquire_set_sort_by_relevance_then_key( @_ );
}

*set_time_limit = *Xapianc::Enquire_set_time_limit;
sub get_mset {
  my $self = $_[0];
  my $nargs = scalar(@_);
  if( $nargs == 4 ) {
    my $type = ref( $_[2] );
    if ( $type eq 'Xapian::RSet' ) {
      # get_mset(first, max, rset)
      splice @_, 2, 0, (0); # insert checkatleast
    }
  }
  return Xapianc::Enquire_get_mset( @_ );
}

*INCLUDE_QUERY_TERMS = *Xapianc::Enquire_INCLUDE_QUERY_TERMS;
*INCLUDE_QUERY_TERMS = *Xapianc::Enquire_INCLUDE_QUERY_TERMS;
*USE_EXACT_TERMFREQ = *Xapianc::Enquire_USE_EXACT_TERMFREQ;
*USE_EXACT_TERMFREQ = *Xapianc::Enquire_USE_EXACT_TERMFREQ;
*get_eset = *Xapianc::Enquire_get_eset;
*get_matching_terms_begin = *Xapianc::Enquire_get_matching_terms_begin;
*get_matching_terms_end = *Xapianc::Enquire_get_matching_terms_end;
*get_description = *Xapianc::Enquire_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ExpandDecider ##############

package Xapian::ExpandDecider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *Xapianc::ExpandDecider___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ExpandDecider($self);
        delete $OWNER{$self};
    }
}

*release = *Xapianc::ExpandDecider_release;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ExpandDeciderAnd ##############

package Xapian::ExpandDeciderAnd;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::ExpandDecider Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ExpandDeciderAnd(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Xapianc::ExpandDeciderAnd___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ExpandDeciderAnd($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ExpandDeciderFilterPrefix ##############

package Xapian::ExpandDeciderFilterPrefix;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::ExpandDecider Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ExpandDeciderFilterPrefix(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Xapianc::ExpandDeciderFilterPrefix___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ExpandDeciderFilterPrefix($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::KeyMaker ##############

package Xapian::KeyMaker;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *Xapianc::KeyMaker___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_KeyMaker($self);
        delete $OWNER{$self};
    }
}

*release = *Xapianc::KeyMaker_release;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::MultiValueKeyMaker ##############

package Xapian::MultiValueKeyMaker;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::KeyMaker Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_MultiValueKeyMaker(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Xapianc::MultiValueKeyMaker___call__;
*add_value = *Xapianc::MultiValueKeyMaker_add_value;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_MultiValueKeyMaker($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Stopper ##############

package Xapian::Stopper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *Xapianc::Stopper___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Stopper($self);
        delete $OWNER{$self};
    }
}

*get_description = *Xapianc::Stopper_get_description;
*release = *Xapianc::Stopper_release;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::SimpleStopper ##############

package Xapian::SimpleStopper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Stopper Xapian );
%OWNER = ();
%ITERATORS = ();
*add = *Xapianc::SimpleStopper_add;
*__call__ = *Xapianc::SimpleStopper___call__;
*get_description = *Xapianc::SimpleStopper_get_description;
*stop_word = *Xapianc::SimpleStopper_stop_word;
sub new {
    my $class = shift;
    my $stopper = Xapianc::new_SimpleStopper();

    bless $stopper, $class;
    foreach (@_) {
	$stopper->add($_);
    }

    return $stopper;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_SimpleStopper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::RangeProcessor ##############

package Xapian::RangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_RangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_RangeProcessor($self);
        delete $OWNER{$self};
    }
}

*check_range = *Xapianc::RangeProcessor_check_range;
*__call__ = *Xapianc::RangeProcessor___call__;
*release = *Xapianc::RangeProcessor_release;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DateRangeProcessor ##############

package Xapian::DateRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RangeProcessor Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DateRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Xapianc::DateRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DateRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::NumberRangeProcessor ##############

package Xapian::NumberRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::RangeProcessor Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_NumberRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Xapianc::NumberRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_NumberRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ValueRangeProcessor ##############

package Xapian::ValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

*__call__ = *Xapianc::ValueRangeProcessor___call__;
*release = *Xapianc::ValueRangeProcessor_release;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::StringValueRangeProcessor ##############

package Xapian::StringValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::ValueRangeProcessor Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_StringValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Xapianc::StringValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_StringValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DateValueRangeProcessor ##############

package Xapian::DateValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::StringValueRangeProcessor Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DateValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Xapianc::DateValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DateValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::NumberValueRangeProcessor ##############

package Xapian::NumberValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::StringValueRangeProcessor Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_NumberValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Xapianc::NumberValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_NumberValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::FieldProcessor ##############

package Xapian::FieldProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_FieldProcessor($self);
        delete $OWNER{$self};
    }
}

*__call__ = *Xapianc::FieldProcessor___call__;
*release = *Xapianc::FieldProcessor_release;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::QueryParser ##############

package Xapian::QueryParser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*FLAG_BOOLEAN = *Xapianc::QueryParser_FLAG_BOOLEAN;
*FLAG_PHRASE = *Xapianc::QueryParser_FLAG_PHRASE;
*FLAG_LOVEHATE = *Xapianc::QueryParser_FLAG_LOVEHATE;
*FLAG_BOOLEAN_ANY_CASE = *Xapianc::QueryParser_FLAG_BOOLEAN_ANY_CASE;
*FLAG_WILDCARD = *Xapianc::QueryParser_FLAG_WILDCARD;
*FLAG_PURE_NOT = *Xapianc::QueryParser_FLAG_PURE_NOT;
*FLAG_PARTIAL = *Xapianc::QueryParser_FLAG_PARTIAL;
*FLAG_SPELLING_CORRECTION = *Xapianc::QueryParser_FLAG_SPELLING_CORRECTION;
*FLAG_SYNONYM = *Xapianc::QueryParser_FLAG_SYNONYM;
*FLAG_AUTO_SYNONYMS = *Xapianc::QueryParser_FLAG_AUTO_SYNONYMS;
*FLAG_AUTO_MULTIWORD_SYNONYMS = *Xapianc::QueryParser_FLAG_AUTO_MULTIWORD_SYNONYMS;
*FLAG_CJK_NGRAM = *Xapianc::QueryParser_FLAG_CJK_NGRAM;
*FLAG_DEFAULT = *Xapianc::QueryParser_FLAG_DEFAULT;
*STEM_NONE = *Xapianc::QueryParser_STEM_NONE;
*STEM_SOME = *Xapianc::QueryParser_STEM_SOME;
*STEM_ALL = *Xapianc::QueryParser_STEM_ALL;
*STEM_ALL_Z = *Xapianc::QueryParser_STEM_ALL_Z;
*STEM_SOME_FULL_POS = *Xapianc::QueryParser_STEM_SOME_FULL_POS;
sub new {
  my $class = shift;
  my $qp = Xapianc::new_QueryParser();

  bless $qp, $class;
  $qp->set_database(@_) if scalar(@_) == 1;

  return $qp;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_QueryParser($self);
        delete $OWNER{$self};
    }
}

*set_stemmer = *Xapianc::QueryParser_set_stemmer;
*set_stemming_strategy = *Xapianc::QueryParser_set_stemming_strategy;
sub set_stopper {
    my ($self, $stopper) = @_;
    $self{_stopper} = $stopper;
    Xapianc::QueryParser_set_stopper( @_ );
}

*set_default_op = *Xapianc::QueryParser_set_default_op;
*get_default_op = *Xapianc::QueryParser_get_default_op;
*set_database = *Xapianc::QueryParser_set_database;
*set_max_expansion = *Xapianc::QueryParser_set_max_expansion;
*set_max_wildcard_expansion = *Xapianc::QueryParser_set_max_wildcard_expansion;
*parse_query = *Xapianc::QueryParser_parse_query;
*add_prefix = *Xapianc::QueryParser_add_prefix;
*add_boolean_prefix = *Xapianc::QueryParser_add_boolean_prefix;
*stoplist_begin = *Xapianc::QueryParser_stoplist_begin;
*stoplist_end = *Xapianc::QueryParser_stoplist_end;
*unstem_begin = *Xapianc::QueryParser_unstem_begin;
*unstem_end = *Xapianc::QueryParser_unstem_end;
sub add_rangeprocessor {
    my ($self, $rproc) = @_;
    push @{$self{_rproc}}, $rproc;
    Xapianc::QueryParser_add_rangeprocessor( @_ );
}

sub add_valuerangeprocessor {
    my ($self, $vrproc) = @_;
    push @{$self{_vrproc}}, $vrproc;
    Xapianc::QueryParser_add_valuerangeprocessor( @_ );
}

*get_corrected_query_string = *Xapianc::QueryParser_get_corrected_query_string;
*get_description = *Xapianc::QueryParser_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ValueSetMatchDecider ##############

package Xapian::ValueSetMatchDecider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::MatchDecider Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ValueSetMatchDecider(@_);
    bless $self, $pkg if defined($self);
}

*add_value = *Xapianc::ValueSetMatchDecider_add_value;
*remove_value = *Xapianc::ValueSetMatchDecider_remove_value;
*__call__ = *Xapianc::ValueSetMatchDecider___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ValueSetMatchDecider($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Weight ##############

package Xapian::Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*TWO_STAGE_SMOOTHING = *Xapianc::Weight_TWO_STAGE_SMOOTHING;
*DIRICHLET_SMOOTHING = *Xapianc::Weight_DIRICHLET_SMOOTHING;
*ABSOLUTE_DISCOUNT_SMOOTHING = *Xapianc::Weight_ABSOLUTE_DISCOUNT_SMOOTHING;
*JELINEK_MERCER_SMOOTHING = *Xapianc::Weight_JELINEK_MERCER_SMOOTHING;
*DIRICHLET_PLUS_SMOOTHING = *Xapianc::Weight_DIRICHLET_PLUS_SMOOTHING;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Weight($self);
        delete $OWNER{$self};
    }
}

*name = *Xapianc::Weight_name;
*get_sumpart = *Xapianc::Weight_get_sumpart;
*get_maxpart = *Xapianc::Weight_get_maxpart;
*get_sumextra = *Xapianc::Weight_get_sumextra;
*get_maxextra = *Xapianc::Weight_get_maxextra;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::BoolWeight ##############

package Xapian::BoolWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_BoolWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::BoolWeight_name;
*get_sumpart = *Xapianc::BoolWeight_get_sumpart;
*get_maxpart = *Xapianc::BoolWeight_get_maxpart;
*get_sumextra = *Xapianc::BoolWeight_get_sumextra;
*get_maxextra = *Xapianc::BoolWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_BoolWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::TfIdfWeight ##############

package Xapian::TfIdfWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_TfIdfWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::TfIdfWeight_name;
*get_sumpart = *Xapianc::TfIdfWeight_get_sumpart;
*get_maxpart = *Xapianc::TfIdfWeight_get_maxpart;
*get_sumextra = *Xapianc::TfIdfWeight_get_sumextra;
*get_maxextra = *Xapianc::TfIdfWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_TfIdfWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::BM25Weight ##############

package Xapian::BM25Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_BM25Weight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::BM25Weight_name;
*get_sumpart = *Xapianc::BM25Weight_get_sumpart;
*get_maxpart = *Xapianc::BM25Weight_get_maxpart;
*get_sumextra = *Xapianc::BM25Weight_get_sumextra;
*get_maxextra = *Xapianc::BM25Weight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_BM25Weight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::BM25PlusWeight ##############

package Xapian::BM25PlusWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_BM25PlusWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::BM25PlusWeight_name;
*get_sumpart = *Xapianc::BM25PlusWeight_get_sumpart;
*get_maxpart = *Xapianc::BM25PlusWeight_get_maxpart;
*get_sumextra = *Xapianc::BM25PlusWeight_get_sumextra;
*get_maxextra = *Xapianc::BM25PlusWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_BM25PlusWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::TradWeight ##############

package Xapian::TradWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_TradWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::TradWeight_name;
*get_sumpart = *Xapianc::TradWeight_get_sumpart;
*get_maxpart = *Xapianc::TradWeight_get_maxpart;
*get_sumextra = *Xapianc::TradWeight_get_sumextra;
*get_maxextra = *Xapianc::TradWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_TradWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::InL2Weight ##############

package Xapian::InL2Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_InL2Weight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::InL2Weight_name;
*get_sumpart = *Xapianc::InL2Weight_get_sumpart;
*get_maxpart = *Xapianc::InL2Weight_get_maxpart;
*get_sumextra = *Xapianc::InL2Weight_get_sumextra;
*get_maxextra = *Xapianc::InL2Weight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_InL2Weight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::IfB2Weight ##############

package Xapian::IfB2Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_IfB2Weight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::IfB2Weight_name;
*get_sumpart = *Xapianc::IfB2Weight_get_sumpart;
*get_maxpart = *Xapianc::IfB2Weight_get_maxpart;
*get_sumextra = *Xapianc::IfB2Weight_get_sumextra;
*get_maxextra = *Xapianc::IfB2Weight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_IfB2Weight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::IneB2Weight ##############

package Xapian::IneB2Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_IneB2Weight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::IneB2Weight_name;
*get_sumpart = *Xapianc::IneB2Weight_get_sumpart;
*get_maxpart = *Xapianc::IneB2Weight_get_maxpart;
*get_sumextra = *Xapianc::IneB2Weight_get_sumextra;
*get_maxextra = *Xapianc::IneB2Weight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_IneB2Weight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::BB2Weight ##############

package Xapian::BB2Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_BB2Weight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::BB2Weight_name;
*get_sumpart = *Xapianc::BB2Weight_get_sumpart;
*get_maxpart = *Xapianc::BB2Weight_get_maxpart;
*get_sumextra = *Xapianc::BB2Weight_get_sumextra;
*get_maxextra = *Xapianc::BB2Weight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_BB2Weight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DLHWeight ##############

package Xapian::DLHWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DLHWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::DLHWeight_name;
*get_sumpart = *Xapianc::DLHWeight_get_sumpart;
*get_maxpart = *Xapianc::DLHWeight_get_maxpart;
*get_sumextra = *Xapianc::DLHWeight_get_sumextra;
*get_maxextra = *Xapianc::DLHWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DLHWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::PL2Weight ##############

package Xapian::PL2Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_PL2Weight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::PL2Weight_name;
*get_sumpart = *Xapianc::PL2Weight_get_sumpart;
*get_maxpart = *Xapianc::PL2Weight_get_maxpart;
*get_sumextra = *Xapianc::PL2Weight_get_sumextra;
*get_maxextra = *Xapianc::PL2Weight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_PL2Weight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::PL2PlusWeight ##############

package Xapian::PL2PlusWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_PL2PlusWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::PL2PlusWeight_name;
*get_sumpart = *Xapianc::PL2PlusWeight_get_sumpart;
*get_maxpart = *Xapianc::PL2PlusWeight_get_maxpart;
*get_sumextra = *Xapianc::PL2PlusWeight_get_sumextra;
*get_maxextra = *Xapianc::PL2PlusWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_PL2PlusWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DPHWeight ##############

package Xapian::DPHWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DPHWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::DPHWeight_name;
*get_sumpart = *Xapianc::DPHWeight_get_sumpart;
*get_maxpart = *Xapianc::DPHWeight_get_maxpart;
*get_sumextra = *Xapianc::DPHWeight_get_sumextra;
*get_maxextra = *Xapianc::DPHWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DPHWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::LMWeight ##############

package Xapian::LMWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_LMWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::LMWeight_name;
*get_sumpart = *Xapianc::LMWeight_get_sumpart;
*get_maxpart = *Xapianc::LMWeight_get_maxpart;
*get_sumextra = *Xapianc::LMWeight_get_sumextra;
*get_maxextra = *Xapianc::LMWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_LMWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::CoordWeight ##############

package Xapian::CoordWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Weight Xapian );
%OWNER = ();
%ITERATORS = ();
*init = *Xapianc::CoordWeight_init;
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_CoordWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Xapianc::CoordWeight_name;
*get_sumpart = *Xapianc::CoordWeight_get_sumpart;
*get_maxpart = *Xapianc::CoordWeight_get_maxpart;
*get_sumextra = *Xapianc::CoordWeight_get_sumextra;
*get_maxextra = *Xapianc::CoordWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_CoordWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Compactor ##############

package Xapian::Compactor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*STANDARD = *Xapianc::Compactor_STANDARD;
*FULL = *Xapianc::Compactor_FULL;
*FULLER = *Xapianc::Compactor_FULLER;
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_Compactor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Compactor($self);
        delete $OWNER{$self};
    }
}

*set_block_size = *Xapianc::Compactor_set_block_size;
*set_renumber = *Xapianc::Compactor_set_renumber;
*set_multipass = *Xapianc::Compactor_set_multipass;
*set_compaction_level = *Xapianc::Compactor_set_compaction_level;
*set_destdir = *Xapianc::Compactor_set_destdir;
*add_source = *Xapianc::Compactor_add_source;
*compact = *Xapianc::Compactor_compact;
*set_status = *Xapianc::Compactor_set_status;
*resolve_duplicate_metadata = *Xapianc::Compactor_resolve_duplicate_metadata;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::PostingSource ##############

package Xapian::PostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_PostingSource($self);
        delete $OWNER{$self};
    }
}

*get_termfreq_min = *Xapianc::PostingSource_get_termfreq_min;
*get_termfreq_est = *Xapianc::PostingSource_get_termfreq_est;
*get_termfreq_max = *Xapianc::PostingSource_get_termfreq_max;
*set_maxweight = *Xapianc::PostingSource_set_maxweight;
*get_maxweight = *Xapianc::PostingSource_get_maxweight;
*get_weight = *Xapianc::PostingSource_get_weight;
*get_docid = *Xapianc::PostingSource_get_docid;
*increment_weight = *Xapianc::PostingSource_increment_weight;
*skip_to = *Xapianc::PostingSource_skip_to;
*check = *Xapianc::PostingSource_check;
*at_end = *Xapianc::PostingSource_at_end;
*name = *Xapianc::PostingSource_name;
*init = *Xapianc::PostingSource_init;
*get_description = *Xapianc::PostingSource_get_description;
*release = *Xapianc::PostingSource_release;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ValuePostingSource ##############

package Xapian::ValuePostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::PostingSource Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ValuePostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_termfreq_min = *Xapianc::ValuePostingSource_get_termfreq_min;
*get_termfreq_est = *Xapianc::ValuePostingSource_get_termfreq_est;
*get_termfreq_max = *Xapianc::ValuePostingSource_get_termfreq_max;
*increment_weight = *Xapianc::ValuePostingSource_increment_weight;
*skip_to = *Xapianc::ValuePostingSource_skip_to;
*check = *Xapianc::ValuePostingSource_check;
*at_end = *Xapianc::ValuePostingSource_at_end;
*get_docid = *Xapianc::ValuePostingSource_get_docid;
*init = *Xapianc::ValuePostingSource_init;
*get_database = *Xapianc::ValuePostingSource_get_database;
*get_slot = *Xapianc::ValuePostingSource_get_slot;
*get_value = *Xapianc::ValuePostingSource_get_value;
*done = *Xapianc::ValuePostingSource_done;
*get_started = *Xapianc::ValuePostingSource_get_started;
*set_termfreq_min = *Xapianc::ValuePostingSource_set_termfreq_min;
*set_termfreq_est = *Xapianc::ValuePostingSource_set_termfreq_est;
*set_termfreq_max = *Xapianc::ValuePostingSource_set_termfreq_max;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ValuePostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ValueWeightPostingSource ##############

package Xapian::ValueWeightPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::ValuePostingSource Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ValueWeightPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_weight = *Xapianc::ValueWeightPostingSource_get_weight;
*name = *Xapianc::ValueWeightPostingSource_name;
*init = *Xapianc::ValueWeightPostingSource_init;
*get_description = *Xapianc::ValueWeightPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ValueWeightPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::DecreasingValueWeightPostingSource ##############

package Xapian::DecreasingValueWeightPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::ValueWeightPostingSource Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_DecreasingValueWeightPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_weight = *Xapianc::DecreasingValueWeightPostingSource_get_weight;
*name = *Xapianc::DecreasingValueWeightPostingSource_name;
*init = *Xapianc::DecreasingValueWeightPostingSource_init;
*increment_weight = *Xapianc::DecreasingValueWeightPostingSource_increment_weight;
*skip_to = *Xapianc::DecreasingValueWeightPostingSource_skip_to;
*check = *Xapianc::DecreasingValueWeightPostingSource_check;
*get_description = *Xapianc::DecreasingValueWeightPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_DecreasingValueWeightPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ValueMapPostingSource ##############

package Xapian::ValueMapPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::ValuePostingSource Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ValueMapPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*add_mapping = *Xapianc::ValueMapPostingSource_add_mapping;
*clear_mappings = *Xapianc::ValueMapPostingSource_clear_mappings;
*set_default_weight = *Xapianc::ValueMapPostingSource_set_default_weight;
*get_weight = *Xapianc::ValueMapPostingSource_get_weight;
*name = *Xapianc::ValueMapPostingSource_name;
*init = *Xapianc::ValueMapPostingSource_init;
*get_description = *Xapianc::ValueMapPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ValueMapPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::FixedWeightPostingSource ##############

package Xapian::FixedWeightPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::PostingSource Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_FixedWeightPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_termfreq_min = *Xapianc::FixedWeightPostingSource_get_termfreq_min;
*get_termfreq_est = *Xapianc::FixedWeightPostingSource_get_termfreq_est;
*get_termfreq_max = *Xapianc::FixedWeightPostingSource_get_termfreq_max;
*get_weight = *Xapianc::FixedWeightPostingSource_get_weight;
*increment_weight = *Xapianc::FixedWeightPostingSource_increment_weight;
*skip_to = *Xapianc::FixedWeightPostingSource_skip_to;
*check = *Xapianc::FixedWeightPostingSource_check;
*at_end = *Xapianc::FixedWeightPostingSource_at_end;
*get_docid = *Xapianc::FixedWeightPostingSource_get_docid;
*name = *Xapianc::FixedWeightPostingSource_name;
*init = *Xapianc::FixedWeightPostingSource_init;
*get_description = *Xapianc::FixedWeightPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_FixedWeightPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::MatchSpy ##############

package Xapian::MatchSpy;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_MatchSpy($self);
        delete $OWNER{$self};
    }
}

*__call__ = *Xapianc::MatchSpy___call__;
*name = *Xapianc::MatchSpy_name;
*merge_results = *Xapianc::MatchSpy_merge_results;
*get_description = *Xapianc::MatchSpy_get_description;
*release = *Xapianc::MatchSpy_release;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::ValueCountMatchSpy ##############

package Xapian::ValueCountMatchSpy;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::MatchSpy Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_ValueCountMatchSpy(@_);
    bless $self, $pkg if defined($self);
}

*get_total = *Xapianc::ValueCountMatchSpy_get_total;
*values_begin = *Xapianc::ValueCountMatchSpy_values_begin;
*values_end = *Xapianc::ValueCountMatchSpy_values_end;
*top_values_begin = *Xapianc::ValueCountMatchSpy_top_values_begin;
*top_values_end = *Xapianc::ValueCountMatchSpy_top_values_end;
*__call__ = *Xapianc::ValueCountMatchSpy___call__;
*name = *Xapianc::ValueCountMatchSpy_name;
*merge_results = *Xapianc::ValueCountMatchSpy_merge_results;
*get_description = *Xapianc::ValueCountMatchSpy_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_ValueCountMatchSpy($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::LatLongCoord ##############

package Xapian::LatLongCoord;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*swig_latitude_get = *Xapianc::LatLongCoord_latitude_get;
*swig_latitude_set = *Xapianc::LatLongCoord_latitude_set;
*swig_longitude_get = *Xapianc::LatLongCoord_longitude_get;
*swig_longitude_set = *Xapianc::LatLongCoord_longitude_set;
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_LatLongCoord(@_);
    bless $self, $pkg if defined($self);
}

*unserialise = *Xapianc::LatLongCoord_unserialise;
*serialise = *Xapianc::LatLongCoord_serialise;
*get_description = *Xapianc::LatLongCoord_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_LatLongCoord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::LatLongCoordsIterator ##############

package Xapian::LatLongCoordsIterator;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_LatLongCoordsIterator(@_);
    bless $self, $pkg if defined($self);
}

*__eq__ = *Xapianc::LatLongCoordsIterator___eq__;
*equals = *Xapianc::LatLongCoordsIterator_equals;
*get_coord = *Xapianc::LatLongCoordsIterator_get_coord;
*increment = *Xapianc::LatLongCoordsIterator_increment;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_LatLongCoordsIterator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::LatLongCoords ##############

package Xapian::LatLongCoords;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*begin = *Xapianc::LatLongCoords_begin;
*end = *Xapianc::LatLongCoords_end;
*size = *Xapianc::LatLongCoords_size;
*empty = *Xapianc::LatLongCoords_empty;
*append = *Xapianc::LatLongCoords_append;
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_LatLongCoords(@_);
    bless $self, $pkg if defined($self);
}

*unserialise = *Xapianc::LatLongCoords_unserialise;
*serialise = *Xapianc::LatLongCoords_serialise;
*get_description = *Xapianc::LatLongCoords_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_LatLongCoords($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::LatLongMetric ##############

package Xapian::LatLongMetric;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_LatLongMetric($self);
        delete $OWNER{$self};
    }
}

*pointwise_distance = *Xapianc::LatLongMetric_pointwise_distance;
*__call__ = *Xapianc::LatLongMetric___call__;
*name = *Xapianc::LatLongMetric_name;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::GreatCircleMetric ##############

package Xapian::GreatCircleMetric;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::LatLongMetric Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_GreatCircleMetric(@_);
    bless $self, $pkg if defined($self);
}

*pointwise_distance = *Xapianc::GreatCircleMetric_pointwise_distance;
*name = *Xapianc::GreatCircleMetric_name;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_GreatCircleMetric($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::LatLongDistancePostingSource ##############

package Xapian::LatLongDistancePostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::ValuePostingSource Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_LatLongDistancePostingSource(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_LatLongDistancePostingSource($self);
        delete $OWNER{$self};
    }
}

*increment_weight = *Xapianc::LatLongDistancePostingSource_increment_weight;
*skip_to = *Xapianc::LatLongDistancePostingSource_skip_to;
*check = *Xapianc::LatLongDistancePostingSource_check;
*get_weight = *Xapianc::LatLongDistancePostingSource_get_weight;
*name = *Xapianc::LatLongDistancePostingSource_name;
*init = *Xapianc::LatLongDistancePostingSource_init;
*get_description = *Xapianc::LatLongDistancePostingSource_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::LatLongDistanceKeyMaker ##############

package Xapian::LatLongDistanceKeyMaker;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::KeyMaker Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_LatLongDistanceKeyMaker(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_LatLongDistanceKeyMaker($self);
        delete $OWNER{$self};
    }
}

*__call__ = *Xapianc::LatLongDistanceKeyMaker___call__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::Database ##############

package Xapian::Database;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian );
%OWNER = ();
%ITERATORS = ();
*add_database = *Xapianc::Database_add_database;
sub new {
    my $pkg = shift;
    my $self = Xapianc::new_Database(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_Database($self);
        delete $OWNER{$self};
    }
}

*reopen = *Xapianc::Database_reopen;
*close = *Xapianc::Database_close;
*get_description = *Xapianc::Database_get_description;
*postlist_begin = *Xapianc::Database_postlist_begin;
*postlist_end = *Xapianc::Database_postlist_end;
*termlist_begin = *Xapianc::Database_termlist_begin;
*termlist_end = *Xapianc::Database_termlist_end;
*has_positions = *Xapianc::Database_has_positions;
*positionlist_begin = *Xapianc::Database_positionlist_begin;
*positionlist_end = *Xapianc::Database_positionlist_end;
*allterms_begin = *Xapianc::Database_allterms_begin;
*allterms_end = *Xapianc::Database_allterms_end;
*get_doccount = *Xapianc::Database_get_doccount;
*get_lastdocid = *Xapianc::Database_get_lastdocid;
*get_avlength = *Xapianc::Database_get_avlength;
*get_total_length = *Xapianc::Database_get_total_length;
*get_termfreq = *Xapianc::Database_get_termfreq;
*term_exists = *Xapianc::Database_term_exists;
*get_collection_freq = *Xapianc::Database_get_collection_freq;
*get_value_freq = *Xapianc::Database_get_value_freq;
*get_value_lower_bound = *Xapianc::Database_get_value_lower_bound;
*get_value_upper_bound = *Xapianc::Database_get_value_upper_bound;
*get_doclength_lower_bound = *Xapianc::Database_get_doclength_lower_bound;
*get_doclength_upper_bound = *Xapianc::Database_get_doclength_upper_bound;
*get_wdf_upper_bound = *Xapianc::Database_get_wdf_upper_bound;
*valuestream_begin = *Xapianc::Database_valuestream_begin;
*valuestream_end = *Xapianc::Database_valuestream_end;
*get_doclength = *Xapianc::Database_get_doclength;
*get_unique_terms = *Xapianc::Database_get_unique_terms;
*keep_alive = *Xapianc::Database_keep_alive;
*get_document = *Xapianc::Database_get_document;
*get_spelling_suggestion = *Xapianc::Database_get_spelling_suggestion;
*spellings_begin = *Xapianc::Database_spellings_begin;
*spellings_end = *Xapianc::Database_spellings_end;
*synonyms_begin = *Xapianc::Database_synonyms_begin;
*synonyms_end = *Xapianc::Database_synonyms_end;
*synonym_keys_begin = *Xapianc::Database_synonym_keys_begin;
*synonym_keys_end = *Xapianc::Database_synonym_keys_end;
*get_metadata = *Xapianc::Database_get_metadata;
*metadata_keys_begin = *Xapianc::Database_metadata_keys_begin;
*metadata_keys_end = *Xapianc::Database_metadata_keys_end;
*get_uuid = *Xapianc::Database_get_uuid;
*locked = *Xapianc::Database_locked;
*get_revision = *Xapianc::Database_get_revision;
*check = *Xapianc::Database_check;
*compact = *Xapianc::Database_compact;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xapian::WritableDatabase ##############

package Xapian::WritableDatabase;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Xapian::Database Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xapianc::delete_WritableDatabase($self);
        delete $OWNER{$self};
    }
}

sub new {
  my $pkg = shift;
  my $self;
  if( scalar(@_) == 0 ) {
    # For compatibility with Search::Xapian
    @_ = ('', $Xapianc::DB_BACKEND_INMEMORY);
  }
  $self = Xapianc::new_WritableDatabase(@_);
  bless $self, $pkg if defined($self);
}

*commit = *Xapianc::WritableDatabase_commit;
*flush = *Xapianc::WritableDatabase_flush;
*begin_transaction = *Xapianc::WritableDatabase_begin_transaction;
*commit_transaction = *Xapianc::WritableDatabase_commit_transaction;
*cancel_transaction = *Xapianc::WritableDatabase_cancel_transaction;
*add_document = *Xapianc::WritableDatabase_add_document;
*delete_document = *Xapianc::WritableDatabase_delete_document;
*delete_document_by_term = *Xapianc::WritableDatabase_delete_document_by_term;
*replace_document = *Xapianc::WritableDatabase_replace_document;
*replace_document_by_term = *Xapianc::WritableDatabase_replace_document_by_term;
*add_spelling = *Xapianc::WritableDatabase_add_spelling;
*remove_spelling = *Xapianc::WritableDatabase_remove_spelling;
*add_synonym = *Xapianc::WritableDatabase_add_synonym;
*remove_synonym = *Xapianc::WritableDatabase_remove_synonym;
*clear_synonyms = *Xapianc::WritableDatabase_clear_synonyms;
*set_metadata = *Xapianc::WritableDatabase_set_metadata;
*get_description = *Xapianc::WritableDatabase_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- CONSTANT STUBS -------

package Xapian;

sub OP_AND () { $Xapianc::OP_AND }
sub OP_OR () { $Xapianc::OP_OR }
sub OP_AND_NOT () { $Xapianc::OP_AND_NOT }
sub OP_XOR () { $Xapianc::OP_XOR }
sub OP_AND_MAYBE () { $Xapianc::OP_AND_MAYBE }
sub OP_FILTER () { $Xapianc::OP_FILTER }
sub OP_NEAR () { $Xapianc::OP_NEAR }
sub OP_PHRASE () { $Xapianc::OP_PHRASE }
sub OP_VALUE_RANGE () { $Xapianc::OP_VALUE_RANGE }
sub OP_SCALE_WEIGHT () { $Xapianc::OP_SCALE_WEIGHT }
sub OP_ELITE_SET () { $Xapianc::OP_ELITE_SET }
sub OP_VALUE_GE () { $Xapianc::OP_VALUE_GE }
sub OP_SYNONYM () { $Xapianc::OP_SYNONYM }
sub OP_MAX () { $Xapianc::OP_MAX }
sub OP_WILDCARD () { $Xapianc::OP_WILDCARD }
sub OP_VALUE_LE () { $Xapianc::OP_VALUE_LE }
sub OP_INVALID () { $Xapianc::OP_INVALID }
sub FLAG_BOOLEAN () { $Xapianc::FLAG_BOOLEAN }
sub FLAG_PHRASE () { $Xapianc::FLAG_PHRASE }
sub FLAG_LOVEHATE () { $Xapianc::FLAG_LOVEHATE }
sub FLAG_BOOLEAN_ANY_CASE () { $Xapianc::FLAG_BOOLEAN_ANY_CASE }
sub FLAG_WILDCARD () { $Xapianc::FLAG_WILDCARD }
sub FLAG_PURE_NOT () { $Xapianc::FLAG_PURE_NOT }
sub FLAG_PARTIAL () { $Xapianc::FLAG_PARTIAL }
sub FLAG_SPELLING_CORRECTION () { $Xapianc::FLAG_SPELLING_CORRECTION }
sub FLAG_SYNONYM () { $Xapianc::FLAG_SYNONYM }
sub FLAG_AUTO_SYNONYMS () { $Xapianc::FLAG_AUTO_SYNONYMS }
sub FLAG_AUTO_MULTIWORD_SYNONYMS () { $Xapianc::FLAG_AUTO_MULTIWORD_SYNONYMS }
sub FLAG_CJK_NGRAM () { $Xapianc::FLAG_CJK_NGRAM }
sub FLAG_DEFAULT () { $Xapianc::FLAG_DEFAULT }
sub STEM_NONE () { $Xapianc::STEM_NONE }
sub STEM_SOME () { $Xapianc::STEM_SOME }
sub STEM_SOME_FULL_POS () { $Xapianc::STEM_SOME_FULL_POS }
sub STEM_ALL () { $Xapianc::STEM_ALL }
sub STEM_ALL_Z () { $Xapianc::STEM_ALL_Z }
sub FLAG_SPELLING () { $Xapianc::FLAG_SPELLING }
sub WILDCARD_LIMIT_ERROR () { $Xapianc::WILDCARD_LIMIT_ERROR }
sub WILDCARD_LIMIT_FIRST () { $Xapianc::WILDCARD_LIMIT_FIRST }
sub WILDCARD_LIMIT_MOST_FREQUENT () { $Xapianc::WILDCARD_LIMIT_MOST_FREQUENT }
sub BAD_VALUENO () { $Xapianc::BAD_VALUENO }
sub DB_CREATE () { $Xapianc::DB_CREATE }
sub DB_CREATE_OR_OPEN () { $Xapianc::DB_CREATE_OR_OPEN }
sub DB_CREATE_OR_OVERWRITE () { $Xapianc::DB_CREATE_OR_OVERWRITE }
sub DB_OPEN () { $Xapianc::DB_OPEN }
sub DB_NO_SYNC () { $Xapianc::DB_NO_SYNC }
sub DB_FULL_SYNC () { $Xapianc::DB_FULL_SYNC }
sub DB_DANGEROUS () { $Xapianc::DB_DANGEROUS }
sub DB_NO_TERMLIST () { $Xapianc::DB_NO_TERMLIST }
sub DB_BACKEND_CHERT () { $Xapianc::DB_BACKEND_CHERT }
sub DB_BACKEND_GLASS () { $Xapianc::DB_BACKEND_GLASS }
sub DB_BACKEND_INMEMORY () { $Xapianc::DB_BACKEND_INMEMORY }
sub DB_BACKEND_STUB () { $Xapianc::DB_BACKEND_STUB }
sub DB_RETRY_LOCK () { $Xapianc::DB_RETRY_LOCK }
sub DBCHECK_SHORT_TREE () { $Xapianc::DBCHECK_SHORT_TREE }
sub DBCHECK_FULL_TREE () { $Xapianc::DBCHECK_FULL_TREE }
sub DBCHECK_SHOW_FREELIST () { $Xapianc::DBCHECK_SHOW_FREELIST }
sub DBCHECK_SHOW_STATS () { $Xapianc::DBCHECK_SHOW_STATS }
sub DBCHECK_FIX () { $Xapianc::DBCHECK_FIX }
sub DBCOMPACT_MULTIPASS () { $Xapianc::DBCOMPACT_MULTIPASS }
sub DBCOMPACT_NO_RENUMBER () { $Xapianc::DBCOMPACT_NO_RENUMBER }
sub DBCOMPACT_SINGLE_FILE () { $Xapianc::DBCOMPACT_SINGLE_FILE }
sub DOC_ASSUME_VALID () { $Xapianc::DOC_ASSUME_VALID }
sub RP_SUFFIX () { $Xapianc::RP_SUFFIX }
sub RP_REPEATED () { $Xapianc::RP_REPEATED }
sub RP_DATE_PREFER_MDY () { $Xapianc::RP_DATE_PREFER_MDY }

# ------- VARIABLE STUBS --------

package Xapian;


package Xapian;

our $VERSION = "1.4.10.0";

# We need to use the RTLD_GLOBAL flag to dlopen() so that other C++
# modules that link against libxapian.so get the *same* value for all the
# weak symbols (eg, the exception classes)
sub dl_load_flags { 0x01 }

# Items to export into caller's namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration use Xapian ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = (
		    'ops' => [ qw(
				  OP_AND
				  OP_OR
				  OP_AND_NOT
				  OP_XOR
				  OP_AND_MAYBE
				  OP_FILTER
				  OP_NEAR
				  OP_PHRASE
				  OP_VALUE_RANGE
				  OP_SCALE_WEIGHT
				  OP_ELITE_SET
				  OP_VALUE_GE
				  OP_VALUE_LE
				 ) ],
		    'db' => [ qw(
				 DB_OPEN
				 DB_CREATE
				 DB_CREATE_OR_OPEN
				 DB_CREATE_OR_OVERWRITE
				 ) ],
		    'enq_order' => [ qw(
				 ENQ_DESCENDING
				 ENQ_ASCENDING
				 ENQ_DONT_CARE
				   ) ],
		    'qpflags' => [ qw(
				 FLAG_BOOLEAN
				 FLAG_PHRASE
				 FLAG_LOVEHATE
				 FLAG_BOOLEAN_ANY_CASE
				 FLAG_WILDCARD
				 FLAG_PURE_NOT
				 FLAG_PARTIAL
				 FLAG_SPELLING_CORRECTION
				 FLAG_SYNONYM
				 FLAG_AUTO_SYNONYMS
				 FLAG_AUTO_MULTIWORD_SYNONYMS
				 FLAG_CJK_NGRAM
				 FLAG_DEFAULT
				 ) ],
		    'qpstem' => [ qw(
				 STEM_NONE
				 STEM_SOME
				 STEM_SOME_FULL_POS
				 STEM_ALL
				 STEM_ALL_Z
				 ) ]
		   );
$EXPORT_TAGS{standard} = [ @{ $EXPORT_TAGS{'ops'} },
			   @{ $EXPORT_TAGS{'db'} },
			   @{ $EXPORT_TAGS{'qpflags'} },
			   @{ $EXPORT_TAGS{'qpstem'} } ];
$EXPORT_TAGS{all} = [ @{ $EXPORT_TAGS{'standard'} }, @{ $EXPORT_TAGS{'enq_order'} } ];

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

# Preloaded methods go here.

our @OP_NAMES;
foreach (@{ $EXPORT_TAGS{'ops'} }) {
  $OP_NAMES[eval $_] = $_;
}

our @DB_NAMES;
foreach (@{ $EXPORT_TAGS{'db'} }) {
  $DB_NAMES[eval $_] = $_;
}

our @FLAG_NAMES;
foreach (@{ $EXPORT_TAGS{'qpflags'} }) {
  $FLAG_NAMES[eval $_] = $_;
}

our @STEM_NAMES;
foreach (@{ $EXPORT_TAGS{'qpstem'} }) {
  $STEM_NAMES[eval $_] = $_;
}

# Compatibility wrapping for Xapian::BAD_VALUENO (wrapped as a constant since
# xapian-bindings 1.4.10).
our $BAD_VALUENO = BAD_VALUENO;

package Xapian::Database;
sub enquire {
  my $self = shift;
  my $enquire = Xapian::Enquire->new( $self );
  if( @_ ) {
    $enquire->set_query( @_ );
  }
  return $enquire;
}

package Xapian::Enquire;
sub matches {
  my $self = shift;
  return $self->get_mset(@_)->items();
}

package Xapian::ESet;
sub items {
  my $self = shift;
  my @array;
  tie( @array, 'Xapian::ESet', $self );
  return @array;
}

use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
	     '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
	     'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

sub TIEARRAY {
  my $class = shift;
  my $eset = shift;
  return bless $eset, $class;
}

sub FETCHSIZE {
    my $self = shift;
    return $self->size();
}

package Xapian::ESetIterator;
use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
	     '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
	     'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

package Xapian::MSet;
sub items {
  my $self = shift;
  my @array;
  tie( @array, 'Xapian::MSet::Tied', $self );
  return @array;
}

sub TIEARRAY {
  my $class = shift;
  my $mset = shift;
  return bless $mset, $class;
}

sub FETCHSIZE {
    my $self = shift;
    return $self->size();
}

package Xapian::MSetIterator;
use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
	     '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
	     'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  bless $self, $class;
  return $self;
}

package Xapian::MSet::Tied;
our @ISA = qw(Xapian::MSet);

package Xapian::PositionIterator;
use overload '++' => sub { $_[0]->increment() },
	     '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
	     '""' => sub { $_[0]->get_description() },
	     '0+' => sub { $_[0]->get_termpos() },
	     'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

sub equal() {
  my ($self, $other) = @_;
  if( UNIVERSAL::isa($other, 'Xapian::PositionIterator') ) {
    Xapianc::PositionIterator_equal1($self, $other);
  } else {
    ($self+0) == ($other+0);
  }
}

sub nequal() {
  my ($self, $other) = @_;
  if( UNIVERSAL::isa($other, 'Xapian::PositionIterator') ) {
    Xapianc::PositionIterator_nequal1($self, $other);
  } else {
    ($self+0) != ($other+0);
  }
}

package Xapian::PostingIterator;
use overload '++' => sub { $_[0]->increment() },
	     '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
	     'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

package Xapian::TermGenerator;
sub set_stopper {
    my ($self, $stopper) = @_;
    $self{_stopper} = $stopper;
    set_stopper1( @_ );
}

package Xapian::TermIterator;
use overload '++' => sub { $_[0]->increment() },
	     '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
	     'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

package Xapian::ValueIterator;
use overload '++' => sub { $_[0]->increment() },
	     '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
	     'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

# Adding CLONE_SKIP functions
package Xapian::LogicError;
sub CLONE_SKIP { 1 }
package Xapian::PositionIterator;
sub CLONE_SKIP { 1 }
package Xapian::PostingIterator;
sub CLONE_SKIP { 1 }
package Xapian::TermIterator;
sub CLONE_SKIP { 1 }
package Xapian::ValueIterator;
sub CLONE_SKIP { 1 }
package Xapian::Document;
sub CLONE_SKIP { 1 }
package Xapian::PostingSource;
sub CLONE_SKIP { 1 }
package Xapian::ValuePostingSource;
sub CLONE_SKIP { 1 }
package Xapian::ValueWeightPostingSource;
sub CLONE_SKIP { 1 }
package Xapian::ValueMapPostingSource;
sub CLONE_SKIP { 1 }
package Xapian::FixedWeightPostingSource;
sub CLONE_SKIP { 1 }
package Xapian::MSet;
sub CLONE_SKIP { 1 }
package Xapian::MSetIterator;
sub CLONE_SKIP { 1 }
package Xapian::ESet;
sub CLONE_SKIP { 1 }
package Xapian::ESetIterator;
sub CLONE_SKIP { 1 }
package Xapian::RSet;
sub CLONE_SKIP { 1 }
package Xapian::MatchDecider;
sub CLONE_SKIP { 1 }
package Xapian::Enquire;
sub CLONE_SKIP { 1 }
package Xapian::Weight;
sub CLONE_SKIP { 1 }
package Xapian::BoolWeight;
sub CLONE_SKIP { 1 }
package Xapian::BM25Weight;
sub CLONE_SKIP { 1 }
package Xapian::TradWeight;
sub CLONE_SKIP { 1 }
package Xapian::Database;
sub CLONE_SKIP { 1 }
package Xapian::WritableDatabase;
sub CLONE_SKIP { 1 }
package Xapian::Query;
sub MatchAll { Xapianc::new_Query('') }
sub MatchNothing { Xapianc::new_Query() }
sub CLONE_SKIP { 1 }
package Xapian::Stopper;
sub CLONE_SKIP { 1 }
package Xapian::SimpleStopper;
sub CLONE_SKIP { 1 }
package Xapian::RangeProcessor;
sub CLONE_SKIP { 1 }
package Xapian::DateRangeProcessor;
sub CLONE_SKIP { 1 }
package Xapian::NumberRangeProcessor;
sub CLONE_SKIP { 1 }
package Xapian::ValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Xapian::StringValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Xapian::DateValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Xapian::NumberValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Xapian::FieldProcessor;
sub CLONE_SKIP { 1 }
package Xapian::QueryParser;
sub CLONE_SKIP { 1 }
package Xapian::Stem;
sub CLONE_SKIP { 1 }
package Xapian::TermGenerator;
sub CLONE_SKIP { 1 }
package Xapian::Sorter;
sub CLONE_SKIP { 1 }
package Xapian::MultiValueSorter;
sub CLONE_SKIP { 1 }
package Xapian::ReplicationInfo;
sub CLONE_SKIP { 1 }
package Xapian::DatabaseMaster;
sub CLONE_SKIP { 1 }
package Xapian::DatabaseReplica;
sub CLONE_SKIP { 1 }
package Xapian::ValueSetMatchDecider;
sub CLONE_SKIP { 1 }
package Xapian::SerialisationContext;
sub CLONE_SKIP { 1 }
package Xapian::MSet::Tied;
sub CLONE_SKIP { 1 }

# Pod document of Xapian
=encoding utf8
=head1 NAME

Xapian - Perl frontend to the Xapian C++ search library.

=head1 SYNOPSIS

  use Xapian;

  my $db = Xapian::Database->new( '[DATABASE DIR]' );
  my $enq = $db->enquire( '[QUERY TERM]' );

  printf "Running query '%s'\n", $enq->get_query()->get_description();

  my @matches = $enq->matches(0, 10);

  print scalar(@matches) . " results found\n";

  foreach my $match ( @matches ) {
    my $doc = $match->get_document();
    printf "ID %d %d%% [ %s ]\n", $match->get_docid(), $match->get_percent(), $doc->get_data();
  }

=head1 DESCRIPTION

This module wraps most methods of most Xapian classes. The missing classes
and methods should be added in the future. It also provides a simplified,
more 'perlish' interface to some common operations, as demonstrated above.

There are some gaps in the POD documentation for wrapped classes, but you
can read the Xapian C++ API documentation at
L<https://xapian.org/docs/apidoc/html/annotated.html> for details of
these.  Alternatively, take a look at the code in the examples and tests.

If you want to use Xapian and the threads module together, make
sure you're using Xapian >= 1.0.4.0 and Perl >= 5.8.7.  As of 1.0.4.0,
Xapian uses CLONE_SKIP to make sure that the perl wrapper objects
aren't copied to new threads - without this the underlying C++ objects can get
destroyed more than once.

If you encounter problems, or have any comments, suggestions, patches, etc
please email the Xapian-discuss mailing list (details of which can be found at
L<https://xapian.org/lists>).

=head2 EXPORT

None by default.

=head1 :db

=over 4

=item DB_OPEN

Open a database, fail if database doesn't exist.

=item DB_CREATE

Create a new database, fail if database exists.

=item DB_CREATE_OR_OPEN

Open an existing database, without destroying data, or create a new
database if one doesn't already exist.

=item DB_CREATE_OR_OVERWRITE

Overwrite database if it exists.

=back

=head1 :ops

=over 4

=item OP_AND

Match if both subqueries are satisfied.

=item OP_OR

Match if either subquery is satisfied.

=item OP_AND_NOT

Match if left but not right subquery is satisfied.

=item OP_XOR

Match if left or right, but not both queries are satisfied.

=item OP_AND_MAYBE

Match if left is satisfied, but use weights from both.

=item OP_FILTER

Like OP_AND, but only weight using the left query.

=item OP_NEAR

Match if the words are near each other. The window should be specified, as
a parameter to C<Xapian::Query::Query>, but it defaults to the
number of terms in the list.

=item OP_PHRASE

Match as a phrase (All words in order).

=item OP_ELITE_SET

Select an elite set from the subqueries, and perform a query with these combined as an OR query.

=item OP_VALUE_RANGE

Filter by a range test on a document value.

=back

=head1 :qpflags

=over 4

=item FLAG_DEFAULT

This gives the QueryParser default flag settings, allowing you to easily add
flags to the default ones.

=item FLAG_BOOLEAN

Support AND, OR, etc and bracketted subexpressions.

=item FLAG_LOVEHATE

Support + and -.

=item FLAG_PHRASE

Support quoted phrases.

=item FLAG_BOOLEAN_ANY_CASE

Support AND, OR, etc even if they aren't in ALLCAPS.

=item FLAG_WILDCARD

Support right truncation (e.g. Xap*).

=item FLAG_PURE_NOT

Allow queries such as 'NOT apples'.

These require the use of a list of all documents in the database
which is potentially expensive, so this feature isn't enabled by
default.

=item FLAG_PARTIAL

Enable partial matching.

Partial matching causes the parser to treat the query as a
"partially entered" search.  This will automatically treat the
final word as a wildcarded match, unless it is followed by
whitespace, to produce more stable results from interactive
searches.

=item FLAG_SPELLING_CORRECTION

=item FLAG_SYNONYM

=item FLAG_AUTO_SYNONYMS

=item FLAG_AUTO_MULTIWORD_SYNONYMS

=back

=head1 :qpstem

=over 4

=item STEM_ALL

Stem all terms.

=item STEM_ALL_Z

Stem all terms and add a "Z" prefix.

=item STEM_NONE

Don't stem any terms.

=item STEM_SOME

Stem some terms, in a manner compatible with Omega (capitalised words and those
in phrases aren't stemmed).

=item STEM_SOME_FULL_POS

Like STEM_SOME but also store term positions for stemmed terms.

=back

=head1 :enq_order

=over 4

=item ENQ_ASCENDING

docids sort in ascending order (default)

=item ENQ_DESCENDING

docids sort in descending order

=item ENQ_DONT_CARE

docids sort in whatever order is most efficient for the backend

=back

=head1 :standard

Standard is db + ops + qpflags + qpstem

=head1 Version functions

=over 4

=item major_version

Returns the major version of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 1.

=item minor_version

Returns the minor version of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 0.

=item revision

Returns the revision of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 9.  In a stable release series, Xapian libraries
with the same minor and major versions are usually ABI compatible, so this
often won't match the third component of $Xapian::VERSION (which is the
version of the Xapian wrappers).

=back

=head1 Numeric encoding functions

=over 4

=item sortable_serialise NUMBER

Convert a floating point number to a string, preserving sort order.

This method converts a floating point number to a string, suitable for
using as a value for numeric range restriction, or for use as a sort
key.

The conversion is platform independent.

The conversion attempts to ensure that, for any pair of values supplied
to the conversion algorithm, the result of comparing the original
values (with a numeric comparison operator) will be the same as the
result of comparing the resulting values (with a string comparison
operator).  On platforms which represent doubles with the precisions
specified by IEEE_754, this will be the case: if the representation of
doubles is more precise, it is possible that two very close doubles
will be mapped to the same string, so will compare equal.

Note also that both zero and -zero will be converted to the same
representation: since these compare equal, this satisfies the
comparison constraint, but it's worth knowing this if you wish to use
the encoding in some situation where this distinction matters.

Handling of NaN isn't (currently) guaranteed to be sensible.

=item sortable_unserialise SERIALISED_NUMBER

Convert a string encoded using sortable_serialise back to a floating
point number.

This expects the input to be a string produced by sortable_serialise().
If the input is not such a string, the value returned is undefined (but
no error will be thrown).

The result of the conversion will be exactly the value which was
supplied to sortable_serialise() when making the string on platforms
which represent doubles with the precisions specified by IEEE_754, but
may be a different (nearby) value on other platforms.

=back

=head1 TODO

=over 4

=item Documentation

Add POD documentation for all classes, where possible just adapted from Xapian
docs.

=item Unwrapped classes

The following Xapian classes are not yet wrapped:
ErrorHandler, user-defined Weight subclasses.

=back

=head1 CREDITS

These SWIG-generated Perl bindings were originally implemented by Kosei
Moriyama in GSoC 2009, and made their debut in the 1.2.4 release.

They take a lot of inspiration and some code from Search::Xapian, a set
of hand-written XS bindings, originally written by Alex Bowley, and later
maintained by Olly Betts.

Search::Xapian owed thanks to Tye McQueen E<lt>tye@metronet.comE<gt> for
explaining the finer points of how best to write XS frontends to C++ libraries,
and James Aylett E<lt>james@tartarus.orgE<gt> for clarifying the less obvious
aspects of the Xapian API.  Patches for wrapping missing classes and other
things were contributed by Olly Betts, Tim Brody, Marcus Ramberg, Peter Karman,
Benjamin Smith, Rusty Conover, Frank Lichtenheld, Henry Combrinck, Jess
Robinson, David F. Skoll, Dave O'Neill, Andreas Marienborg, Adam Sjgren,
Dmitry Karasik, and Val Rosca.

=head1 AUTHOR

Please report any bugs/suggestions to E<lt>xapian-discuss@lists.xapian.orgE<gt>
or use the Xapian bug tracker L<https://xapian.org/bugs>.  Please do
NOT use the CPAN bug tracker or mail contributors individually.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SEE ALSO

L<Xapian::BM25Weight>,
L<Xapian::BoolWeight>,
L<Xapian::Database>,
L<Xapian::Document>,
L<Xapian::Enquire>,
L<Xapian::MultiValueSorter>,
L<Xapian::PositionIterator>,
L<Xapian::PostingIterator>,
L<Xapian::QueryParser>,
L<Xapian::Stem>,
L<Xapian::TermGenerator>,
L<Xapian::TermIterator>,
L<Xapian::TradWeight>,
L<Xapian::ValueIterator>,
L<Xapian::Weight>,
L<Xapian::WritableDatabase>,
and
L<https://xapian.org/>.

=cut
1;
